# 字符串：

### 1. 常见类型

* KMP 算法
  
KMP算法：在当前对文本串和模式串检索的过程中，若出现了不匹配，如何充分利用已经匹配的部分

例：文本串：aabaabaaf  模式串：aabaaf
前缀：包含首字母，不含尾字母的所有子串，都是前缀
后缀：包含尾字母，不含首字母的所有子串，都是后缀
最长相等前后缀：aabaa

前缀表：next 数组：[0,1,0,1,2,0]
a 0
aa 1
aab 0
aaba 1
aabaa 2
aabaaf 0

next数组：表示上述前缀表。遇到冲突时候，next数组用来确定回退到下一个位置。即：
  
  f的位置发生了冲突，则看f上一位字符的在前缀表中的值，即 2 （对应字符b）

求 next 数组的四个步骤：

1. 初始化：
  i: 代表 指向后缀末尾位置，
  j: 0  代表 指向前缀末尾位置，以及最长相等前后缀长度
  next[0]: 0

2. 处理前后缀不相同的情况:
  while(j > 0 && s[i] !== s[j]) 
    j = next[j - 1]  // j 找它前一位需要回退的位置进行回退

3. 处理前后缀相同的情况
  if (s[i] === s[j]) 
    j = j + 1 // j 加 1

4. 更新next数组的值
  next[i] = j


### 2. 易错

* 也能画出一个树状结构，但是实际是一个小根堆或者大根堆
* 需要模拟一个堆结构



[264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

````
// 代码和上题一模一样
var nthUglyNumber = function(n) {

};

````


### 马拉车算法

马拉车算法（Manacher's algorithm）是一种用来解决最长回文子串问题的算法。它的时间复杂度为 O(n)

马拉车算法的核心思想是利用回文串的对称性，避免重复计算。具体来说，算法维护一个数组 P，其中 P[i] 表示以位置 i 为中心的最长回文半径。在计算 P[i] 的过程中，算法会利用之前已经计算出的 P 数组的信息，尽可能地推进 i 的值，从而减少重复计算。

具体的计算过程可以分为以下几个步骤：

初始化 P 数组。由于一个字符本身就是一个回文串，因此 P[0] 至 P[n-1] 都初始化为 1。

计算 P 数组。从左到右依次计算 P[1] 至 P[n-2] 的值。对于每个位置 i，算法会尽可能地利用之前已经计算出的 P 数组的信息，从而推进 i 的值。具体来说，算法会维护两个变量：C 和 R。其中，C 表示当前已知的最长回文串的中心位置，R 表示该回文串的右边界。在计算 P[i] 的过程中，算法会分为以下两种情况：

情况一：i 在 R 的左侧。这种情况下，i 的回文半径至少为 min(R-i, P[2C-i])，其中 P[2C-i] 表示以 C 为中心的回文串在 i 的对称位置的长度。在计算完 P[i] 之后，如果 i+P[i] 大于 R，则需要更新 C 和 R 的值。

情况二：i 在 R 的右侧。这种情况下，i 的回文半径至少为 1。在计算完 P[i] 之后，如果 i+P[i] 大于 R，则需要更新 C 和 R 的值。

找到最长回文子串。遍历 P 数组，找到最大的 P[i] 值及其对应的位置 i。最长回文子串就是以 i 为中心、长度为 P[i]-1 的子串。

总体来说，马拉车算法利用了回文串的对称性，通过维护一个数组 P 来避免重复计算。在计算过程中，算法会尽可能地推进中心位置 C 和右边界 R，从而减少重复计算。



[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)

````
var lengthOfLongestSubstring = function(s) {
  
};
````

